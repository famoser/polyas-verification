# Questions

This document tracks open and answered questions

## Specification

The questions in this chapter block the implementation of the verifier.

1. (B.1, page 50) What is the hexadecimal representation of the `RECEIPT-VERIFICATION-KEY` RSA public key? I would propose to use PEM PUBLIC KEY representation, which is also what OpenSSL takes as an argument (see https://www.rfc-editor.org/rfc/rfc7468#section-13, which in turn requires an ASN.1 SubjectPublicKeyInfo encoding https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.7).

> The format is X.509, represented as a hex string.
> PEM was designed for stand-alone files, but here the key is transmitted within a JSON. Note how PEM encapsulates X.509.

2. (B.2, page 52) The example represents `proofOfKnowledgeOfEncryptionCoins.[].c`, `proofOfKnowledgeOfEncryptionCoins.[].f` and , `proofOfKnowledgeOfPrivateCredential.c` within 21 bytes (with the first byte being 0); but `proofOfKnowledgeOfPrivateCredential.f` within 20 bytes (with no first zero-byte). Could you please clarify what the logic here is?

> The .f and .c fields of the zero-knowledge proofs are of type BigInteger and are represented as decimal numbers (without leading zeros).


## Suggestions to improve clarity of specification

1. (B.2, page 52) The conventions in Section A.1.2 refer to SHA512, while SHA256 is specified to be used.

> Will be clarified.

2. In any case, please specify the unicode of the markers used, as latex will likely not preserve it during render.

3. Complete test data for every algorithm, and for a full run of a protocol would help to diagnose errors when implementing the verifier?

4. Where is the reference implementation for the universal verifiability procedure (as mentioned in the spec)?


## Improvement suggestions

1. To check whether a receipt of a ballot fingerprint corresponds to a ballot registered at the voting server, every registered ballot has to be hashed to find the one ballot with the correct fingerprint. How about including the fingerprint in the ballot entry, too? The second device can still verify that the fingerprint actually corresponds to the ballot, while it is much faster to discover the correct ballot.
2. The different formats needed for the ballot entry digest (label = UTF-8, ciphertext = byte array, proof of knowledge = long number) increase burden of implementation, and possibly lead to hard-to-debug mistakes. How about everywhere using HEX?
3. The receipt in the PDF file uses two minus `--` as an encapsulation boundary marker. Why not use the PEM encapsulation marker (five `-----`) so the receipt is a valid PEM file? Then a PEM parser can be reused; and I think it changes nothing about PDF validity. 
Towards continuing the implementation:

## Organisational questions

1. I would like to include the specification document next to my source code, i.e. publish it to GitHub. Is this possible?
2. There are a couple of typos in the specification document. I'd prefer to fix them directly and create a PR against the documentation; saves time on both ends. Is this possible?
2. How will the boards be made accessible, and when/how can this be tested?

## Security questions

Questions to understand the design principles behind the protocol.

1. Is there a computational and/or symbolic proof over the presented protocol?
> No. A preprint of the paper describing the essential idea is available here: https://arxiv.org/pdf/2304.09456.pdf.

2. Any particular reason why `secp256k1` is chosen, and not `ed25519`?
> secp256k1 is of prime order, as required by the zero-knowledge proofs. ed25519 is not of a prime order.

3. Is the receipt generated on the client, or on the server?
> It is generated by the second device application; hence client-side.


